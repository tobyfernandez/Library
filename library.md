Tobias Fernandez  
DS-1043  
17 December 2025  
# Library
## create_table()
Create table creates a table, row by row, in the form of strings. It requires two parameters, a header, and data. It aligns the text it creates based on what sort of data type it is and adjusts the column widths to accommodate the longest data of that type. The pre-conditions require that the inputted headers must be a list of strings, and that all the data must be either all dictionaries or all lists, within a list. The post-conditions dictate that a formatted string that represents a table will be returned. An invariant of this function is that the data alignment (i.e. right, left, center) is determined by the data type. Assumptions are made that the inputted data rows are consistently formatted and that there are no repeated headers. The complexity of this function is relatively low: O(n * m), needing only the columns and the rows taken into account. The space complexity is also low at O(m). This program could potentially be used any time tabular data needs to be displayed, and its parameters could be further changed to allow for a wider range of data to be inputted into it. 

## caesar_cipher()
The caesar cypher fuction encrypts plain text by shifting each letter in each word it contains by a certain number of places in the alphabet. It takes two parameters: plaintext, the string of text to be shifted, and rotation, the amount of places in the alphabet each letter will be shifted. The rotation amount is set to 13 by default. The pre-conditions are simply that a string has been inputted to be shifted, and the post-conditions dictate that the shifted string is returned. The invariants of this function are that the alphabet wraps around when the last letter of the alphabet ('z') is reached and continues on at the beginning with 'a'. Also, any character that is not a letter is left untouched by the cypher. The time complexity and space complexity of the caesar_cypher function are the same, O(n) - it is quite simple. Its use cases are in simple encryption, or as a first step for a more complex type of encryption. 	

## merge_sort() and merge()
Merge_sort and merge work together to sort lists by a recursive method of splitting and joining. Their pre-conditions are that data is a list of sortable elements, and that left and right are sorted lists. Post conditions for the functions are that merge_sort returns a single sorted list and merge returns a merged list containing all the elements in left and right sorted in the specified manner. The assumption is that the elements in the lists can be compared by normal operators. The space complexity of both functions is O(n). The time complexity of merge_sort is O(n log n) since it must divide the list and then put it back together. The time complexity of merge is just O(n). 
The pro of these functions is that they efficiently sort, and even though they are both required they both have little space complexity. Typical use cases of these functions may be in scenarios where sorting large datasets is necessary or scenarios where the order of equal elements needs to be preserved. 
## calculate_idf()
The calculate_idf function measures the inverse document frequency for each term in a list of sentences. This measurement represents the importance of the term on the scale of the whole corpus. A pre-condition of this function is that the one parameter it requires, sentences, is a list of lists, where each inner list is a sentence made up by a string. The post-condition is that it returns a dictionary, where the terms being measured are the keys and the values are their IDF values. The invariants of this function include IDF values being non-negative. Any terms found in every sentence (such as articles) will yield the lowest IDF. It is assumed that every sentence will include at least one term. The time complexity of this function is O(n * m), and its space complexity is O(n). Long documents with many unique words may be slow to process with this function. This function could be used in any situation where IDF needs to be calculated, which can range from textual analysis to applications such as the one I wrote it for, which was for the purpose of making a fuzzy matching suggestion program. 
## bubble_search()
The bubble_search function compares each pair of adjacent values in the list and swaps them if they are out of order. If the reverse boolean is in effect, then the desired order is reversed. The pre-conditions of the function are that the data parameter is a list of elements of the same type, and that the reverse parameter is set to True if not left as false. The post-condition of the function is that it returns the sorted list in the order indicated. The invariant of the function is that after each pass through the list, the largest value that had not been sorted has gotten to where it needs to be. It is assumed that the inputted list is mutable and its elements can be compared by normal operators. The time complexity of this function is O(n*n) = O(n^2). The space complexity of the function is O(1). Bubble sort, though it doesn't take up much space at all, is quite slow on large datasets. However, it has use cases on small lists where a more complex algorithm is not required. 
